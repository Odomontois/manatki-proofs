\import Data.Bool
\import Equiv
\import Paths
\import Set
\import Function

\class DecEq (A : \Set)
  | \infix 2 == (a b : A) : Dec (a = b)

\instance decEqBool : DecEq Bool
  | == => impl
  \where {
    \func impl (a b : Bool) : Dec (a = b) \elim  a, b
      | true, true => yes idp
      | false, false => yes idp
      | true, false => no true/=false
      | false, true => no (true/=false o inv)
  }

\instance decEqUnit : DecEq (\Sigma)
  | == a b => yes (Path.inProp a b)

\instance decEqSigma {A : DecEq} (B : A -> \Set) (BD : \Pi (a : A) -> DecEq (B a)) : DecEq (\Sigma (a : A) (B a))
  | == s1 s2 =>
    \let se : QEquiv => sigmaEquiv B s1 s2
    \in \case s1.1 == s2.1 \with {
      | no n => no (\lam e => n (pmap (\lam s => s.1) e))
      | yes e1 => \case (transport B e1 s1.2 == {BD s2.1} s2.2) \with {
        | yes e2 => yes (se.ret (e1, e2))
        | no n => no (\lam e => \case se.f e \with {
          | (p1, p2) => n (transport (\lam p => transport B p s1.2 = s2.2) (Path.inProp {s1.1 = s2.1} p1 e1) p2 )
        })
      }
    }

