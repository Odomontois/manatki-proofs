\import Logic
\import Logic.Classical
\import Meta
\import Paths
\import Paths.Meta
\import Set

\func Subs (A : \Set) => A -> \Prop

\func isInj {A B : \Set} (f : A -> B) => \Pi (x y : A) -> f x = f y -> x = y

\func eq1 {A : \Set} (a b : A) : \Prop => a = b

\func isSur {A B : \Set} (f : A -> B) : \Prop =>
  \Pi (b : B) -> TruncP (\Sigma (a : A) (f a = b))

\func cantor1 (A : \Set) : \Sigma (f : A -> Subs A) (isInj f) =>
  (=, \lam x y eq => inv (coe (\lam i => (eq @ i) x) idp right))


\func P!=!P (P : \Prop) (f : P -> Not P) (g : Not P -> P) : Empty =>
  \let x : P => g (\lam p => f p p) \in f x x

\func cantor2 (A : \Set) (f : A -> Subs A) (t : isSur f) : Empty =>
  \case t (P f) \with {
    | inP (px, pe) => P!=!P (P f px)
        (\lam e _ => run {e , rewrite pe, e})
        (\lam n _ => run {n, unfold P, rewrite pe, n})
  } \where {
  \func P {A : \Set} (f : A -> Subs A) (x : A) => Not (f x x )
}



