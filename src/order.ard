\import Order.LinearOrder
\import Order.StrictOrder
\import Order.PartialOrder
\import Order.Lattice
\import Set
\import Logic
\import Paths
\import HLevel

\data \infixl 2 Xor (A B : \Prop)
  | IsLeft A (Not B)
  | IsRight B (Not A)
  \where {
    \use \level xorIsProp {A B : \Prop} (x1 x2 : Xor A B) : x1 = x2
      | IsLeft  a1 nb1, IsLeft a2 nb2 => pmap2 IsLeft (Path.inProp a1 a2) (Path.inProp nb1 nb2)
      | IsRight b1 na1, IsRight b2 na2 => pmap2 IsRight (Path.inProp b1 b2) (Path.inProp na1 na2)
      | IsLeft  a nb, IsRight b na => absurd (na a)
      | IsRight b na, IsLeft a nb => absurd (na a)
  }

\open StrictPoset
\open LinearOrder.Dec

\func xcompare {A : \Set} {to : LinearOrder.Dec A} (a b : A) : (a = b) Xor a < {to} b Xor a > b =>
  \case trichotomy a b \with {
    | byLeft a=b => IsLeft(IsLeft a=b (\lam a<b => distinct= a<b a=b)) (\lam a>b => distinct= a>b (inv a=b))
    | byRight (byLeft a<b) => IsLeft ( IsRight a<b (\lam a=b => distinct= a<b a=b)) (\lam a>b => distinct< a<b a>b)
    | byRight (byRight a>b) => IsRight a>b (\lam a<=b => \case a<=b \with {
      | IsLeft a=b a!<b => distinct= a>b (inv a=b)
      | IsRight a<b a!=b => distinct< a<b a>b
    })
  } \where {
  \lemma distinct= {A : \Set} {to : LinearOrder.Dec A} {a b : A} (lt : a < b) (e : a = b) : Empty =>
    <-irreflexive b (coe  (\lam i => e @ i < b) lt right)

  \lemma distinct< {A : \Set} {to : LinearOrder.Dec A} {a b : A} (lt : a < b) (gt : a > b) : Empty =>
    <-irreflexive a (<-transitive a b a lt gt)
}

\open LinearOrder.Dec (=>TotalOrder)

\func max {A  : LinearOrder.Dec} (a a' : A) : A => meet {=>TotalOrder} a a'

\func min {A : LinearOrder.Dec } (a a' : A) : A => join {=>TotalOrder} a a'

\func \infixl 4 ~*> {A  : Preorder} {a b c : A} (ie1 : a <= b) (ie2 : b <= c) : a <= c =>
  <=-transitive a b c ie1 ie2

\open JoinSemilattice

\lemma join<=meet {A : Lattice} (a b : A) : join a b <= meet a b =>
  join-left _ _ ~*> meet-left _ _

\lemma join-swap2 {A : JoinSemilattice } (a b c : A) : join (join a b) c = join (join b a) c =>
  <=-antisymmetric _ _ (join-swap' _ _ _) (join-swap' _ _ _) \where {
  \lemma join-comm' {A : JoinSemilattice} (a b : A) : join a b <= join b a =>
    coe (\lam i => join a b <= join-comm a b @ i ) (<=-reflexive _) right

  \lemma join-swap' {A : JoinSemilattice} (a b c : A) : join (join a b) c <= join (join b a) c =>
    (join-univ _ _ _ (join-left _ _ ~*> join-comm' _ _) (join-right _ _))
}

\lemma meet-comm {E : MeetSemilattice}(x y : E) : meet x y = meet y x =>
  <=-antisymmetric _ _
                   (meet-univ _ _ _ (meet-right y x) (meet-left y x))
                   (meet-univ _ _ _ (meet-right x y) (meet-left x y))

\lemma meet-idemp {E : MeetSemilattice} (x : E) : meet x x = x =>
  <=-antisymmetric _ _  (meet-univ x x x (<=-reflexive x) (<=-reflexive x)) (meet-left x x)

\lemma meet-assoc {E : MeetSemilattice}  (x y z : E) : meet (meet x y) z = meet x (meet y z) =>
  <=-antisymmetric _ _
                   (meet-univ _ _ _ (meet-univ _ _ _ (meet-left _ _) (meet-left y z ~*> meet-right _ _)) (meet-right y z ~*> meet-right _ _) )
                   (meet-univ _ _ _ (meet-left x y ~*> meet-left _ _) (meet-univ _ _ _ (meet-right x y ~*> meet-left _ _) (meet-right _ _)))

\lemma meet<=  {E : MeetSemilattice} (x y : E) (x<=y : x <= y) : meet x y = y =>
  <=-antisymmetric _ _ (meet-univ _ _ _ x<=y (<=-reflexive _)) (meet-right x y)

\lemma join-semi-distrib {E : Lattice} (x y z : E) : meet (join x y) (join x z) <= join x (meet y z) =>
  meet-univ _ _ _
            (join-univ _ _ _ (join-left x y) (join-right x y ~*> meet-left y z))
            (join-univ _ _ _ (join-left x z) (join-right x z ~*> meet-right y z))


