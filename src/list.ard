\import Logic
\import Logic
\import Paths
\import monoid
\import order
\import sets
\import Function
\import Order.LinearOrder
\import Order.PartialOrder
\import Order.Lattice

\data List (A : \Type)
  | nil
  | \infixr 6 :: (a : A) (tail : List A) \where {
  \lemma discriminate {A : \Type} {a : A} {t : List A} (p : nil = a :: t) : Empty => coe (discrT o (p @)) () right
    \where {
      \func discrT {A : \Type} (as : List A) : \Prop
        | nil => \Sigma
        | :: _ _ => Empty
    }

  \lemma ::-injective {A : \Set} {a a' : A} {t  t' : List A} (p : a :: t = a' :: t') : \Sigma (a = a') (t = t') =>
    ( pmap (head a) p , pmap tail p )
    \where {
      \func head {A : \Type} (a : A) (l : List A) : A \elim l
        | nil => a
        | :: b _ => b

      \func tail {A : \Type} (l : List A) : List A \elim l
        | nil => nil
        | :: _ t => t
    }

  \func length {A : \Type } (l : List A) : Nat
    | nil => Nat.zero
    | :: _ t => suc (length t)

  \func \infixr 5 ++ {A : \Type} (l1 : List A) (l2 : List A) : List A
    | nil, l => l
    | (:: h t), l => h :: (t ++ l)

  \func ++nil {A : \Type} (l : List A): l ++ nil = l
    | nil => idp
    | (:: h t) => pmap (:: h) (++nil t)

  \func assoc {A : \Type} (la lb lc : List A) : (la ++ lb) ++ lc = la ++ (lb ++ lc)  \elim la
    | nil => idp
    | (:: h la') => pmap (:: h) (assoc la' lb lc)

  \instance listMonoid {A : \Set}: Monoid (List A)
    | empty => nil
    | |+| => List.++
    | left_empty a => idp
    | right_empty => List.++nil
    | assoc  => List.assoc

  \open TotalOrder (totality)
  \open || (byLeft, byRight)
  \open JoinSemilattice (join-comm)

  \func minimum {A : \Set} {sa : JoinSemilattice A} (a : A) (as : List A) : A \elim as
    | nil => a
    | :: a' tail =>  minimum (join a a') tail
    \where {
      \lemma unordered {A : \Set} {to : JoinSemilattice A} (a a' : A) (as : List A) :
        minimum a (a' :: as) = minimum a' (a :: as) => pmap (\lam x => minimum x as) (join-comm _ _)
    }

  \func SortedList (A : \Set) {po : Poset A} : \Set => \Sigma (l : List A) (ListIsOrdered l)

  \func SortedList1 (A : \Set) {po : Poset A} : \Set => \Sigma (h : A) (t : List A) (ListIsOrdered (h :: t))

  \func insertionSort {A : \Set} {la : Lattice A} (as : List A) : SortedList A
    | nil => (nil, ord-nil idp)
    | :: h t => \let (h, t, ord) => sort1 h t \in (h :: t, ord)
    \where {
      \record Inserted {A : \Set} {la : Lattice A} (a : A) {
        | head : A
        | tail  : List A
        | ordered : ListIsOrdered ( head :: tail)
        | lower : head >= a
      }

      \func insLower {A : \Set} {la : Lattice A} {a b : A} (p : b <= a) (i : Inserted a) : Inserted b \cowith
        | head => i.head
        | tail => i.tail
        | ordered => i.ordered
        | lower => p ~*>  i.lower

      \open ListIsOrdered

      \func sort1 {A : \Set} {la : Lattice A} (a : A) (as : List A) : SortedList1 A \elim as
        | nil => (a, nil, ord-single a idp)
        | :: b t =>
          \let | (b', t', ord) => sort1 b t
               | ins : Inserted (join a b') => insert a b' ord
          \in (ins.head, ins.tail, ins.ordered)

      \func insert{A : \Set} {la : Lattice A} (a h : A) {as : List A} (od : ListIsOrdered (h :: as)) : Inserted (join a h) \elim od
        | ord-nil p => absurd (List.discriminate (inv p))
        | ord-single _ _ =>
          \let jab<=mab =>  <=-transitive _ _ _ (join-left a h)  (meet-left a h)
          \in \new Inserted {
            | head => join a h
            | tail => meet a h :: nil
            | ordered => ord-cons _ _ _ jab<=mab (ord-single _ idp) idp
            | lower => <=-reflexive _
          }
        | ord-cons b c t b<=c next p =>
          \let | f => join a h
               | s => meet a h
               | (h=b, _p1) => List.::-injective p
               | ins : Inserted (join s c) => insert s c next
               | h<=c => transport (\lam x => x <= c) (inv h=b) b<=c
               | f<=s => join-left a h ~*> meet-left a h
               | f<=c => join-right a h ~*> h<=c
               | f<=h' :  f <= ins.head => join-univ _ _ _ f<=s f<=c  ~*> ins.lower
          \in \new Inserted {
            | head => join a h
            | tail => ins.head :: ins.tail
            | ordered => ord-cons (join a h) ins.head ins.tail f<=h' ins.ordered idp
            | lower => <=-reflexive f
          }

      \func insert2  {A : \Set}{la : Lattice A} (a b h : A) {as : List A} (od : ListIsOrdered (h :: as))
        : Inserted (join (join a b) h) =>
        \let | ins1 : Inserted (join b h) =>  insert b h od
             | ins2 : Inserted (join a ins1.head) => insert a ins1.head ins1.ordered
             | ie => join (join a b) h
             | ie<=a : ie <= a => join-left _ _ ~*> join-left _ _
             | ie<=h' : ie <= ins1.head => {?} -- join-right _ _ ~*> ins1.lower
        \in {?} -- insLower (join-univ _ _ _ ie<=a ie<=h') ins2

      \lemma insert2comm {A : \Set} {la : Lattice A} (a b h : A) {as : List A}  (od : ListIsOrdered (h :: as)) =>
        insert2 a b h od = transport Inserted (join-swap2 )
    }
}

\data ListIsOrdered {A : \Set} {po : Poset A} (l : List A)
  | ord-nil (p : l = nil)
  | ord-single (a : A) (p : l = a :: nil)
  | ord-cons (a b : A) (t : List A) (po : a <= b) (next : ListIsOrdered ( b :: t)) (p : l = a :: b :: t ) \where {
  \use \level orderedList-is-prop {A : \Set} {po : Poset A} {l : List A} (o1 o2 : ListIsOrdered l) : o1 = o2 \elim o1, o2
    | ord-nil p1 , ord-nil p2 => pmap ord-nil (Path.inProp _ _)
    | ord-nil p1 , ord-single a2 p2 => absurd (List.discriminate ((inv p1) *>  p2))
    | ord-nil p1 , ord-cons a2 b2 t2 po2 next2 p2 => absurd (List.discriminate ((inv p1) *>  p2))
    | ord-single a1 p1,  ord-nil p2 => absurd (List.discriminate ((inv p2) *>  p1))
    | ord-single a1 p1,  ord-single a2 p2 =>
      \let | (a1=a2 , _p) => List.::-injective ( (inv p1) *> p2 )
           | ei (i : I) => l = (a1=a2 @ i) :: nil
      \in path (\lam i => ord-single (a1=a2 @ i) (pathInProp ei p1 p2 @ i))
    | ord-single a1 p1,  ord-cons a2 b2 t2 po2 next2 p2 =>
      \let | (_p , nil=t2) => List.::-injective ((inv p1) *> p2)
      \in absurd (List.discriminate nil=t2)
    | ord-cons a1 b1 t1 po1 next1 p1 , ord-nil p2 => absurd (List.discriminate ((inv p2) *>  p1))
    | ord-cons a1 b1 t1 po1 next1 p1 , ord-single a2 p2 =>
      \let | (_p, nil=t1) => List.::-injective ((inv p2) *> p1)
      \in absurd (List.discriminate nil=t1)
    | ord-cons a1 b1 t1 po1 next1 p1 , ord-cons a2 b2 t2 po2 next2 p2 =>
      \let | (a1=a2, bt1=bt2)      => List.::-injective ((inv p1) *> p2)
           | (b1=b2, t1=t2)        => List.::-injective bt1=bt2
           | nexti (i : I) : \Prop => ListIsOrdered ((b1=b2 @ i) :: (t1=t2 @ i))
           | next1=next2           => pathInProp nexti next1 next2
           | pi (i : I) : \Prop    => l = (a1=a2 @ i) :: (b1=b2 @ i) :: (t1=t2 @ i)
           | p1=p2                 => pathInProp pi p1 p2
           | poi (i : I) : \Prop   => (a1=a2 @ i) <= (b1=b2 @ i)
           | po1=po2               => pathInProp poi po1 po2
      \in path(\lam i => ord-cons (a1=a2 @ i) (b1=b2 @ i) (t1=t2 @ i) (po1=po2 @ i) (next1=next2 @ i) (p1=p2 @ i))
}

\data Elem {A : \Type} (e : A) (l : List A)
  | Here (t : List A) (eq : e :: t = l)
  | There (h : A) (t : List A) (elem : Elem e t) (eq : h :: t = l) \where {
  \func here!=there {A B : \Type} (e h : A) (l t1 t2 : List A) (el : Elem e t2)
                    (eq1 : e :: t1 = l) (eq2 : h :: t2 = l)
                    (p : Here t1 eq1 = There h t2 el eq2 )  : B =>
    coe (\lam i => \case p @ i \with { Here _ _ => \Sigma | There _ _ _ _  => B }) () right

  \func tail-elem {A : \Type} (e h : A) (l : List A) (elem : Elem e l) : Elem e (h :: l) => There h l elem idp
}


