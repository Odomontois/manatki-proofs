\import DecEq
\import HLevel
\import Logic
\import Logic
\import Paths
\import monoid
\import order
\import Function
\import Order.LinearOrder
\import Order.PartialOrder
\import Order.Lattice
\import Set

\data List (A : \Type)
  | nil
  | \infixr 6 :: (a : A) (tail : List A) \where {
  \lemma discriminate {A : \Type} {a : A} {t : List A} (p : nil = a :: t) : Empty => coe (discrT o (p @)) () right
    \where {
      \func discrT {A : \Type} (as : List A) : \Prop
        | nil => \Sigma
        | :: _ _ => Empty
    }

  \lemma head-monotone {A : \Set} {la : Poset A} (a b : A) (as : List A) (p : a <= b) : head a as <= head b as \elim as
    | nil => p
    | :: c _ => <=-reflexive c

  \func head {A : \Type} (a : A) (l : List A) : A \elim l
    | nil => a
    | :: b _ => b

  \func tail {A : \Type} (l : List A) : List A \elim l
    | nil => nil
    | :: _ t => t

  \lemma ::-injective {A : \Set} {a a' : A} {t  t' : List A} (p : a :: t = a' :: t') : \Sigma (a = a') (t = t') =>
    ( pmap (head a) p , pmap tail p )
    \where {

    }

  \func length {A : \Type} (l : List A) : Nat
    | nil => Nat.zero
    | :: _ t => suc (length t)

  \func \infixr 5 ++ {A : \Type} (l1 : List A) (l2 : List A) : List A
    | nil, l => l
    | (:: h t), l => h :: (t ++ l)

  \func ++nil {A : \Type} (l : List A): l ++ nil = l
    | nil => idp
    | (:: h t) => pmap (:: h) (++nil t)

  \func assoc {A : \Type} (la lb lc : List A) : (la ++ lb) ++ lc = la ++ (lb ++ lc)  \elim la
    | nil => idp
    | (:: h la') => pmap (:: h) (assoc la' lb lc)

  \open TotalOrder (totality)
  \open || (byLeft, byRight)
  \open JoinSemilattice (join-comm)

  \func minimum {A : \Set} {sa : JoinSemilattice A} (a : A) (as : List A) : A \elim as
    | nil => a
    | :: a' tail => minimum (join a a') tail
    \where {
      \lemma unordered {A : \Set} {to : JoinSemilattice A} (a a' : A) (as : List A) :
        minimum a (a' :: as) = minimum a' (a :: as) => pmap (\lam x => minimum x as) (join-comm _ _)
    }
}

\instance listMonoid {A : \Set}: Monoid (List A)
  | empty => nil
  | |+| => List.++
  | left_empty a => idp
  | right_empty => List.++nil
  | assoc  => List.assoc

\instance listDecEq {A : DecEq}: DecEq (List A)
  | == => impl \where {
  \lemma impl {A : DecEq} (a b : List A) : Dec (a = b) \elim a, b
    | nil, nil => yes (idp)
    | nil, :: _ _ => no List.discriminate
    | :: _ _, nil => no (List.discriminate o inv)
    | :: ha ta, :: hb tb => \case ha == hb \with {
      | no n => no (\lam e => n (pmap (List.head ha) e))
      | yes eh => \case impl ta tb \with {
        | no n => no (\lam e => n (pmap List.tail e))
        | yes et => yes (pmap2 (::) eh et)
      }
    }
}

\data Elem {A : \Type} (e : A) (l : List A) \elim l
  | :: h t => Here (e = h)
  | :: h t => There (Elem e t) \where {
  \func no-nil {A B : \Type} (a : A) (eq : Elem a nil) : B

  \func here!=there {A B : \Type} (e h : A) (t : List A) (el : Elem e t)
                    (eq : e = h) (p : Here eq = There el)  : B =>
    coe (\lam i => \case p @ i \with {
    Here _ => \Sigma | There _ => B
    }) () right
}

\instance elemDecEq {A : \Set} {e : A} {l : List A} : DecEq (Elem e l)
  | == => {?}




