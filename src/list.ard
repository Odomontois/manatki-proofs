\import Logic
\import Logic
\import Paths
\import monoid
\import order
\import sets
\import Function
\import Order.LinearOrder
\import Order.PartialOrder
\import Order.Lattice

\data List (A : \Type)
  | nil
  | \infixr 6 :: (a : A) (tail : List A) \where {
  \lemma discriminate {A : \Type} {a : A} {t : List A} (p : nil = a :: t) : Empty => coe (discrT o (p @)) () right
    \where {
      \func discrT {A : \Type} (as : List A) : \Prop
        | nil => \Sigma
        | :: _ _ => Empty
    }

  \lemma head-monotone {A : \Set} {la : Poset A} (a b : A) (as : List A) (p : a <= b) : head a as <= head b as \elim as
    | nil => p
    | :: c _ => <=-reflexive c

  \func head {A : \Type} (a : A) (l : List A) : A \elim l
    | nil => a
    | :: b _ => b

  \func tail {A : \Type} (l : List A) : List A \elim l
    | nil => nil
    | :: _ t => t

  \lemma ::-injective {A : \Set} {a a' : A} {t  t' : List A} (p : a :: t = a' :: t') : \Sigma (a = a') (t = t') =>
    ( pmap (head a) p , pmap tail p )
    \where {

    }

  \func length {A : \Type } (l : List A) : Nat
    | nil => Nat.zero
    | :: _ t => suc (length t)

  \func \infixr 5 ++ {A : \Type} (l1 : List A) (l2 : List A) : List A
    | nil, l => l
    | (:: h t), l => h :: (t ++ l)

  \func ++nil {A : \Type} (l : List A): l ++ nil = l
    | nil => idp
    | (:: h t) => pmap (:: h) (++nil t)

  \func assoc {A : \Type} (la lb lc : List A) : (la ++ lb) ++ lc = la ++ (lb ++ lc)  \elim la
    | nil => idp
    | (:: h la') => pmap (:: h) (assoc la' lb lc)

  \instance listMonoid {A : \Set}: Monoid (List A)
    | empty => nil
    | |+| => List.++
    | left_empty a => idp
    | right_empty => List.++nil
    | assoc  => List.assoc

  \open TotalOrder (totality)
  \open || (byLeft, byRight)
  \open JoinSemilattice (join-comm)

  \func minimum {A : \Set} {sa : JoinSemilattice A} (a : A) (as : List A) : A \elim as
    | nil => a
    | :: a' tail =>  minimum (join a a') tail
    \where {
      \lemma unordered {A : \Set} {to : JoinSemilattice A} (a a' : A) (as : List A) :
        minimum a (a' :: as) = minimum a' (a :: as) => pmap (\lam x => minimum x as) (join-comm _ _)
    }


\func sort {A : \Set} {la : Lattice A} (as : List A) : List A
  | nil => nil
  | :: a t => insert a (sort t)

  \where {
    \open ListIsOrdered

    \func insert{A : \Set} {la : Lattice A} (a : A) (as : List A)  : List A \elim as
      | nil => a :: nil
      | :: b t => (join a b) :: insert (meet a b) t

    \lemma insSort-sorting {A : \Set} {la : Lattice A} (as : List A) : ListIsOrdered (sort as)
      | nil => ord-nil idp
      | :: a t => insert-keeps-order a (sort t) (insSort-sorting t)

    \lemma insert-keeps-order {A : \Set} {la : Lattice A} (a : A) (as : List A) (od : ListIsOrdered as) : ListIsOrdered (insert a as) =>
      \let ins : Inserted a as => insert-cons a as od
      \in transport ListIsOrdered ins.el ins.od

    \record Inserted  {A : \Set} {la : Lattice A} (a : A) (as : List A){
      | h : A
      | tail : List A
      | od : ListIsOrdered (h :: tail)
      | el : h :: tail = insert a as
      | eh : join (List.head a as) a = h
    }

    \open JoinSemilattice

    \func insert-cons {A : \Set} {la : Lattice A} (a : A) (as : List A) (od : ListIsOrdered as) : Inserted a as \elim as
      | nil => inil a
      | :: b t =>
        \let r => insert-cons (meet a b) t (tailIsOrdered od)
        \in icons a b t od r
      \where {
        \open List

        \func inil {A : \Set} {la : Lattice A} (a : A) : Inserted a nil \cowith
          | h => a
          | tail => nil
          | od => ord-single a idp
          | el => idp
          | eh => join-idemp _

        \func icons {A : \Set} {la : Lattice A} (a b : A) (as : List A)
                    (od : ListIsOrdered (b :: as)) (rec : Inserted (meet a b) as)
          : Inserted a (b :: as) \cowith
          | h => join a b
          | tail => insert (meet a b) as
          | od =>
            \let  | h'<=h : join a b <= head (meet a b) as => join-right _ _ ~*> head-is-min od ~*> head-monotone _ _ _ (meet-right _ _)
                  | ie : join a b <= join (head (meet a b) as) (meet a b) => join-univ _ _ _ h'<=h (join<=meet _ _)
            \in ord-cons (join a b) rec.h rec.tail (transport (<= (join a b)) rec.eh ie) rec.od (pmap (:: (join a b)) (inv rec.el))
          | el => idp
          | eh => join-comm _ _
      }
  }

\data ListIsOrdered {A : \Set} {po : Poset A} (l : List A)
  | ord-nil (p : l = nil)
  | ord-single (a : A) (p : l = a :: nil)
  | ord-cons (a b : A) (t : List A) (po : a <= b) (next : ListIsOrdered ( b :: t)) (p : l = a :: b :: t ) \where {
  \use \level orderedList-is-prop {A : \Set} {po : Poset A} {l : List A} (o1 o2 : ListIsOrdered l) : o1 = o2 \elim o1, o2
    | ord-nil p1 , ord-nil p2 => pmap ord-nil (Path.inProp _ _)
    | ord-nil p1 , ord-single a2 p2 => absurd (discriminate ((inv p1) *>  p2))
    | ord-nil p1 , ord-cons a2 b2 t2 po2 next2 p2 => absurd (discriminate ((inv p1) *>  p2))
    | ord-single a1 p1,  ord-nil p2 => absurd (discriminate ((inv p2) *>  p1))
    | ord-single a1 p1,  ord-single a2 p2 =>
      \let | (a1=a2 , _p) => ::-injective ( (inv p1) *> p2 )
           | ei (i : I) => l = (a1=a2 @ i) :: nil
      \in path (\lam i => ord-single (a1=a2 @ i) (pathInProp ei p1 p2 @ i))
    | ord-single a1 p1,  ord-cons a2 b2 t2 po2 next2 p2 =>
      \let | (_p , nil=t2) => ::-injective ((inv p1) *> p2)
      \in absurd (List.discriminate nil=t2)
    | ord-cons a1 b1 t1 po1 next1 p1 , ord-nil p2 => absurd (discriminate ((inv p2) *>  p1))
    | ord-cons a1 b1 t1 po1 next1 p1 , ord-single a2 p2 =>
      \let | (_p, nil=t1) => ::-injective ((inv p2) *> p1)
      \in absurd (List.discriminate nil=t1)
    | ord-cons a1 b1 t1 po1 next1 p1 , ord-cons a2 b2 t2 po2 next2 p2 =>
      \let | (a1=a2, bt1=bt2)      => ::-injective ((inv p1) *> p2)
           | (b1=b2, t1=t2)        => ::-injective bt1=bt2
           | nexti (i : I) : \Prop => ListIsOrdered ((b1=b2 @ i) :: (t1=t2 @ i))
           | next1=next2           => pathInProp nexti next1 next2
           | pi (i : I) : \Prop    => l = (a1=a2 @ i) :: (b1=b2 @ i) :: (t1=t2 @ i)
           | p1=p2                 => pathInProp pi p1 p2
           | poi (i : I) : \Prop   => (a1=a2 @ i) <= (b1=b2 @ i)
           | po1=po2               => pathInProp poi po1 po2
      \in path(\lam i => ord-cons (a1=a2 @ i) (b1=b2 @ i) (t1=t2 @ i) (po1=po2 @ i) (next1=next2 @ i) (p1=p2 @ i))

  \lemma tailIsOrdered {A : \Set} {po : Poset A} {a : A} {l : List A} (p : ListIsOrdered (a :: l)): ListIsOrdered l
    | ord-nil e => absurd (List.discriminate (inv e))
    | ord-single h e => \let (a=h, l=nil) => ::-injective e \in ord-nil l=nil
    | ord-cons a b t po next e  => \let (a=h, l=bt) => ::-injective e \in transport ListIsOrdered (inv l=bt) next

  \lemma head-is-min {A : \Set} {po : Poset A} {a : A} {l : List A} (p : ListIsOrdered (a :: l)) : a <= List.head a l \elim l, p
    | nil, _ => <=-reflexive _
    | :: b t, ord-nil p => absurd (discriminate (inv p))
    | :: b t, ord-single b' p => \let (_h, te) => ::-injective p \in absurd (discriminate (inv te))
    | :: b t, ord-cons a' b' t' po _ p =>
      \let | (a=a', bt=bt') => ::-injective p
           | (b=b', t=t') => ::-injective bt=bt'
      \in transport2 (<=) (inv a=a') (inv b=b') po
}

\data Elem {A : \Type} (e : A) (l : List A)
  | Here (t : List A) (eq : e :: t = l)
  | There (h : A) (t : List A) (elem : Elem e t) (eq : h :: t = l) \where {
  \func here!=there {A B : \Type} (e h : A) (l t1 t2 : List A) (el : Elem e t2)
                    (eq1 : e :: t1 = l) (eq2 : h :: t2 = l)
                    (p : Here t1 eq1 = There h t2 el eq2 )  : B =>
    coe (\lam i => \case p @ i \with { Here _ _ => \Sigma | There _ _ _ _  => B }) () right

  \func tail-elem {A : \Type} (e h : A) (l : List A) (elem : Elem e l) : Elem e (h :: l) => There h l elem idp
}


