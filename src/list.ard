\import Logic
\import Logic
\import Paths
\import monoid
\import order
\import sets
\import Function
\import Order.LinearOrder

\data List (A : \Type)
  | nil
  | \infixr 6 :: (a : A) (tail : List A) \where {
  \func length {A : \Type } (l : List A) : Nat
    | nil => Nat.zero
    | :: _ t => suc (length t)

  \func \infixr 5 ++ {A : \Type} (l1 : List A) (l2 : List A) : List A
    | nil, l => l
    | (:: h t), l => h :: (t ++ l)

  \func ++nil {A : \Type} (l : List A): l ++ nil = l
    | nil => idp
    | (:: h t) => pmap (:: h) (++nil t)

  \func assoc {A : \Type} (la lb lc : List A) : (la ++ lb) ++ lc = la ++ (lb ++ lc)  \elim la
    | nil => idp
    | (:: h la') => pmap (:: h) (assoc la' lb lc)

  \instance listMonoid {A : \Set}: Monoid (List A)
    | empty => nil
    | |+| => List.++
    | left_empty a => idp
    | right_empty => List.++nil
    | assoc  => List.assoc

  \open TotalOrder (totality)
  \open || (byLeft, byRight)


  \func minimum {A : \Set} {to : XOrder A} (a : A) (as : List A) : A \elim as
    | nil => a
    | :: a' tail => \case total a a' \with{
      | IsLeft _ _ => minimum a tail
      | IsRight _ _ => minimum a' tail
    } \where {
    \lemma unordered {A : \Set} {to : XOrder A} (a a' : A) (as : List A) :
      minimum a (a' :: as) = minimum a' (a :: as) => {?}
  }

}

\data Elem {A : \Type} (e : A) (l : List A)
  | Here (t : List A) (eq : e :: t = l)
  | There (h : A) (t : List A) (elem : Elem e t) (eq : h :: t = l) \where {
  \func here!=there {A B : \Type} (e h : A) (l t1 t2 : List A) (el : Elem e t2)
                    (eq1 : e :: t1 = l) (eq2 : h :: t2 = l)
                    (p : Here t1 eq1 = There h t2 el eq2 )  : B =>
    coe (\lam i => \case p @ i \with { Here _ _ => \Sigma | There _ _ _ _  => B }) () right

  \func tail-elem {A : \Type} (e h : A) (l : List A) (elem : Elem e l) : Elem e (h :: l) => There h l elem idp
}


