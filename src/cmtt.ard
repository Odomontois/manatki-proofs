\import Logic
\import Logic.Meta
\import Paths
\import Paths.Meta
\import funs
\import list
\import Function
\import list.structural

\data Type (T : \Set)
  | just T
  | \infixr 7 --> (Type T) (Type T)
  | [] (List (Type T)) (Type T)

\func Ctx (T : \Set) : \Set => List (Type T)

\func Valid (T : \Set) : \Set => List (\Sigma (Type T) (Ctx T))

\cons \infixr 8 []> {T : \Set} (A B : Type T) : Type T => [] (single A) B

\open List \hiding (at)
\open Index \hiding (at, swap-head, swap)
\open Symmetry

\data ICML {T : \Set} (D : Valid T) (G R : Ctx T) \elim R
  | single A => hyp (Index A G)
  | single A => ctxhyp {X : Ctx T} (Index (A, X) D) (ICML D G X)
  | single (-->  A B) => I-> (ICML D (A :: G) (single B))
  | single B => E-> (A : Type T) (ICML D G (single (A --> B))) (ICML D G (single A))
  | single ([] X A) => I[] (ICML D X (single A))
  | single C => E[] (X : Ctx T) (A : Type T) (ICML D G (single ([] X A))) (ICML ((A, X) :: D) G (single C))
  | :: A B => ctx:: (ICML D G (single A)) (ICML D G B)
  | nil => ctxnil \where {
  \func Stat {T : \Set} (t : Type T) : \Set => ICML nil nil (single t)

  \func example-[1] {T : \Set} (C D A : Type T):  Stat $ C []> A --> [] (C :: D :: nil) A =>
    I-> $ E[] (single C) A (hyp @0) $  I[] $ ctxhyp @0 $ hyp @0

  \func example-[2] {T : \Set} (C D A : Type T): Stat $ [] (C :: C :: nil) A --> C []> A =>
    I-> $ E[] (C :: C :: nil) A (hyp @0) $ I[] $ ctxhyp  @0 $ ctx:: (hyp @0) $ hyp @0

  \func example-[3] {T : \Set} (A : Type T): Stat $ A []> A => I[] $ hyp @0

  \func example-[4] {T : \Set} (A B C : Type T): Stat $ A []> B --> A []>  B []>  C --> A []> C =>
    I->      $
    E[] (single A) B (hyp @0) $
    I-> $
    E[] (single A) ([] (single B) C) (hyp @0) $
    I[] $
    E[] (single B) C (ctxhyp @0 (hyp @0)) $
    ctxhyp @0 $ ctxhyp @2 (hyp @0)

  \func example-[5] {T : \Set} (A : Type T) : Stat (([] nil A)  --> A) =>
    I-> $ E[] nil A (hyp @0) (ctxhyp @0 ctxnil)

  \func example-[6] {T : \Set} (A C D : Type T) : Stat $ C []> A --> D []> C []> A =>
    I-> $ E[] (single C) A (hyp @0) $ I[] $ I[] $ ctxhyp @0 (hyp @0)

  \func example-[7] {T : \Set} (A B C D : Type T) : Stat $ C []> (A --> B) --> D []> A --> ([] (C :: D :: nil) B) =>
    I-> $
    I-> $
    E[] (single C) (A --> B) (hyp @1) $
    E[] (single D) A (hyp @0) $
    I[] $
    E-> A (ctxhyp @1 (hyp @0)) (ctxhyp @0 (hyp @1))

  \func example-[8] {T : \Set} (A B C : Type T) : Stat $ A []> (A --> B) --> B []> C --> A []> C =>
    I-> $
    I-> $
    E[] (single A) (A --> B) (hyp @1) $
    E[] (single B) C (hyp @0) $
    I[] $
    ctxhyp @0 $
    E-> A (ctxhyp @1 $ hyp @0) $ hyp @0
}

\data SICML {T : \Set} (D : Valid T) (G R : Ctx T) \elim R
  | single (just _ \as p)  => init (Index p G)
  | single C => reflect {A : Type T} {X : Ctx T} (Index (A, X) D) (SICML D G X) (SICML D (A :: G) (single C))
  | single (--> A B) => ->R (SICML D (A :: G) (single B))
  | single C => ->L {A B : Type T} (Index (A --> B) G) (SICML D G (single A)) (SICML D (B :: G) (single C))
  | single ([] X A) => []R (SICML D X (single A))
  | single C => []L {A : Type T} {X : Ctx T} (Index ([] X A) G) (SICML ((A, X) :: D) G (single C))
  | nil => nilctx
  | :: A R => ::ctx (SICML D G (single A)) (SICML D G R) \where {
  \func \infix 2 ==> {T : \Set} (GD : \Sigma  (Valid T) (Ctx T)) (C : Type T) : \Set
    | (D, G), C => SICML D G (single C)

  \func swap-G {T : \Set} {D : Valid T} {G R : Ctx T} (G' : Ctx T) {A' B' : Type T}
               (p : SICML D (G' ++ A' :: B' :: G) R) : SICML D (G' ++ B' :: A' :: G) R \elim R, p
    | single (just _ \as p), init i => init $ Index.swap i
    | single C, reflect {A} e1 px ac => reflect e1 (swap-G _ px) $ swap-G (A :: G') ac
    | single (--> A B), ->R px => ->R $ swap-G (A :: G') px
    | single C, ->L {A} {B} i l r => ->L (Index.swap i) (swap-G _ l) (swap-G (B :: G') r)
    | single ([] X A), []R p => []R p
    | single C, []L {A} i p => []L (Index.swap i) (swap-G _ p)
    | nil, nilctx => nilctx
    | :: C R, ::ctx h t => ::ctx (swap-G _ h) (swap-G _ t)

  \func swap-D {T : \Set} {D : Valid T} {G R X Y : Ctx T} (D' : Valid T) {A' B' : Type T}
               (p : SICML (D' ++ (A', X) :: (B', Y) :: D) G R) : SICML (D' ++ (B', Y) :: (A', X) :: D) G R \elim R, p
    | single (just _ \as p), init i => init  i
    | single C, reflect {A} e1 px ac => reflect (Index.swap e1) (swap-D _ px) (swap-D _ ac)
    | single (--> A B), ->R px => ->R $ swap-D _ px
    | single C, ->L {A} {B} i l r => ->L i (swap-D _ l) (swap-D _ r)
    | single ([] X A), []R p => []R $ swap-D _ p
    | single C, []L {A} {X} i p => []L i $ swap-D ((A, X) :: D') p
    | nil, nilctx => nilctx
    | :: C R, ::ctx h t => ::ctx (swap-D _ h) (swap-D _ t)

  \func sym-G {T : \Set} {D : Valid T} {R : Ctx T}: Symmetry (SICML D __ R) \cowith
    | swap p => swap-G _ p

  \func sym-D {T : \Set} {G R : Ctx T}: Symmetry (SICML __ G R) \cowith
    | swap p => swap-D _ p

  \func Weak-D {T : \Set} {D : Valid T}  {G Y R : Ctx T} {E : Type T} (p : SICML D G R): SICML ((E, Y) :: D) G R \elim R, p
    | single (just _), init pc => init pc
    | single C, reflect e px ac => reflect (There e) (Weak-D px) (Weak-D ac)
    | single (--> A B), ->R px => ->R $ Weak-D px
    | single C, ->L i l r => ->L i (Weak-D l) (Weak-D r)
    | single ([] X A), []R p => []R $ Weak-D p
    | single C, []L i p => []L i $ swap-head {sym-D} $ Weak-D p
    | nil, nilctx => nilctx
    | :: C R, ::ctx h t => ::ctx (Weak-D h) (Weak-D t)

  \func Weak-G {T : \Set} {D : Valid T}  {G R : Ctx T} {E : Type T} (p : SICML D G R): SICML D (E :: G) R \elim R, p
    | single (just _), init pc => init (There pc)
    | single C, reflect e px ac => reflect e (Weak-G px) $ swap-head {sym-G} $ Weak-G ac
    | single (--> A B), ->R px => ->R $ Symmetry.swap-head {sym-G} $ Weak-G px
    | single C, ->L i l r => ->L (There i) (Weak-G l) $ swap-head {sym-G} $ Weak-G r
    | single ([] X A), []R p => []R p
    | single C, []L i p => []L (There i) $ Weak-G p
    | nil, nilctx => nilctx
    | :: C R, ::ctx h t => ::ctx (Weak-G h) (Weak-G t)

  \func Identity {T : \Set} {D : Valid T} {G R : Ctx T}  : SICML D (R ++ G) R \elim R
    | nil => nilctx
    | :: (just t) R => ::ctx (init @0) $ pull-head {sym-G} Identity
    | :: (--> A B) R => ::ctx (->R $ ->L @1 Identity Identity) $ pull-head {sym-G} Identity
    | ::  ([] X A) R =>
      ::ctx ([]L @0 $ []R $ reflect @0 (transport (SICML _ __ X) (List.++nil X) Identity) Identity) $
      pull-head {sym-G} Identity

  \func IdentIn {T : \Set} {D : Valid T} {G : Ctx T} {C : Type T} (e : Index C G) : (D, G) ==> C \elim G, e
    | :: A G, Here e => transport (\lam x => SICML D (x :: G) _) e Identity
    | :: A G, There e => Weak-G $ IdentIn e

  \func Contract-g {T : \Set} {D : Valid T} {G R : Ctx T} {A' : Type T} (G' : Ctx T) (e : Index A' G) (p : SICML D (G' ++ A' :: G) R) :
    SICML D (G' ++ G) R \elim R, e, p
    | single (just _), e, init i => init $ squash-with e i
    | single C, e, reflect {A} i l r =>
      reflect i (Contract-g G' e l) $ Contract-g (A :: G') e r
    | single (--> A B), e, ->R p => ->R $ Contract-g (A :: G') e p
    | single C, e, ->L {A} {B} i l r => ->L (squash-with e i) (Contract-g G' e l) $ Contract-g (B :: G') e r
    | single ([] A B), e, []R p => []R p
    | single C, e, []L i p => []L (squash-with e i) $ Contract-g G' e p
    | nil , e, nilctx => nilctx
    | :: C R , e, ::ctx p pr => ::ctx (Contract-g G' e p) (Contract-g G' e pr)

  \func Cut-0 {T : \Set} {D : Valid T}  {I : Type T} {G R : Ctx T}
            (p1 : (D, G) ==> I) (p2 : SICML D (I :: G) R) : SICML D G R \elim I, R, p1, p2
    | I, nil, p1, nilctx => nilctx
    | I, :: C R, p1, ::ctx p2 r => ::ctx (Cut-0 p1 p2) (Cut-0 p1 r)
    | I, R, ::ctx p1 nilctx, p2 => Cut-0 p1 p2
    | just _ , single (just _), init i,  init j => init $ Index.squash-0 i j
    | I, single C, reflect {A} i l r, p2 => reflect i l $ Cut-0 r $ swap-head {sym-G} $ Weak-G p2
    | just _ , single C, init i,  reflect {A} j l r => reflect j (Contract-g nil i l) (Contract-g (single A) i r)
    | just _ , single (--> A B), init i,  ->R p2 => ->R (Contract-g (single A) i p2)
    | just _ , single C, init i,  ->L {A} {B} j l r => \case j \with {
      | There j' => ->L j' (Contract-g nil i l) (Contract-g (single B) i r)
      | Here p => contradiction
    }
    | just _ , single C, init i,  []L j p2 => []L (squash-0 i j) $ Contract-g nil i p2
    | --> A B, single (just _), ->R px, init j => init ( \case j \with {
      | Here p => contradiction
      | There j' => j'
    })
    | I , single C, p1, reflect {E} {X} j l r => reflect j (Cut-0 p1 l) $ {?}
    |  I, single C, ->L i l r, p2 => ->L i l $ Cut-0 r $ swap-head {sym-G} $ Weak-G p2
    | I, single ([] X R), p1, []R p2 => []R p2
    | I, single C, []L i p1, p2 => []L i $ Cut-0 p1 $ Weak-D p2
    | --> A B, single C, ->R px, p2 => {?}
    | I, single (--> A B), p1, ->R p2 => {?}
    | [] X I, single C, []R p1, p2 => {?}

  \func WCut {T : \Set} {D : Valid T}  (G : Ctx T) {I : Type T} {G' G'' R : Ctx T}
            (p1 : (D, G' ++ G'') ==> I) (p2 : SICML D (G ++ G' ++ I :: G'') R) : SICML D (G ++ G' ++ G'') R \elim G, I, R, p1, p2

    | G, I, nil, p1, nilctx => nilctx
    | G, I, :: C R, p1, ::ctx p2 r => ::ctx (WCut G p1 p2) (WCut G p1 r)
    | G, I, R, ::ctx p1 nilctx, p2 => WCut G p1 p2
    | G, I , single C, p1, reflect {E} {X} j l r =>  reflect j (WCut G p1 l) $ WCut (E :: G) p1 r
    | G, just t , single (just u), init i,  init j => init $ squash i j
    | G, I, single C, reflect {A} i l r, p2 => {?}
    | G, just _ , single C, init i,  reflect {A} j l r => {?}
    | G, just _ , single (--> A B), init i,  ->R p2 => {?}
    | G, just _ , single C, init i,  ->L {A} {B} j l r => {?}
    | G, just _ , single C, init i,  []L j p2 => {?}
    | G,  I, single C, ->L i l r, p2 => {?}
    | G, I, single ([] X R), p1, []R p2 => []R p2
    | G, I, single C, []L i p1, p2 => {?}
    | G, --> A B, single C, ->R px, p2 => {?}
    | G, I, single (--> A B), p1, ->R p2 => {?}
    | G, [] X I, single C, []R p1, p2 => {?}



  --    | single C, reflect i l r => reflect i (Cut p1 l) $ Cut (Weak-G p1) $ swap-head {sym-G} r

  --    | just t, single (just t'), init e, init e' => init $ squash e e'
  --    | _ , _, _ , _ => {?}

  -- []L @0 $ []R $ reflect @0 {?} {?}
}


